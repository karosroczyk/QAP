\chapter{Operacja krzyżowania}\label{cha:pierwszyDokument}

Operacja krzyżowania jest drugą, obok mutacji, operacją należącą do grupy operatorów genetycznych. Głównym celem istnienia krzyżowania w algorytmie ewolucji różnicowej jest wprowadzenie dodatkowego zróżnicowania wśród osobników. Potomek będący wynikiem operacji krzyżowania $o_{i}$ zgodnie ze schematem \ref{algo}, powstaje poprzez wymianę kodu genetycznego osobnika wynikowego operatora mutacji $u_{i}$ oraz osobnika $x_{i}$ należącego do populacji rodziców. Operacji tej towarzyszy również parametr $C{r}$ określany mianem współczynnika krzyżowania. Wartości tego współczynnika może zostać przypisana stała wartość, bądź też może ona ulegać zmianie wraz z biegiem algorytmu. \\
W algorytmach ewolucyjnych stosuje się między innymi metody krzyżowania takie jak krzyżowanie dwupunktowe, wielopunktowe czy też równomierne \cite{diff2}, natomiast w przypadku algorytmów ewolucji różnicowej spotykane warianty to krzyżowanie dwumianowe czy też wykładnicze (odpowiednik krzyżowania dwupunktowego w algorytmie ewolucyjnym). Wspomniane wyżej metody nie znajdują jednak bezpośredniego zastosowania w konteście problemów optymalizacji, w których to poszczególne osobniki są permutacjami, jako że osobniki w metodach tych są ciągami bitowymi. Istnieje wówczas ryzyko duplikacji genu w osobniku wynikowym. W celu dostosowania algorytmu ewolucji różnicowej tak by rozwiązywał on problem NP-trudny jakim jest kwadratowe zagadnienie przydziału (QAP) należy dokonać modyfikacji standardowej implementacji metod krzyżowania, w taki sposób by powtórzenia w genach nie występowały. Niemniej jednak wspomniane wyżej modyfikacje wprowadzają do algorytmu dodatkową losowość co niekoniecznie może wpłynąć korzystnie na całość działania algorytmu. \\
W literaturze \cite{cross} można znaleźć metody krzyżowania dostosowane do problemów w których to osobniki są reprezentowane przez permutacje, a nie poprzez wartości binarne jak ma to miejsce w klasycznym algorytmie ewolucyjnym. Do grona tych metod zaliczamy między innymi OX(Order Crossover), CX(Cycle Crossover) czy też PMX(Parcial Mapped Crossover). Implementacje i omówienie wspomnianych metod krzyżowania zostanie zaprezentowane w poniższych podrozdziałach.
%---------------------------------------------------------------------------

\section{Klasyczne krzyżowanie : krzyżowanie dwumianowe}\label{sec:strukturaDokumentu}

Zgodnie z \cite{doktorat}, \cite{diff2} w klasycznym algorytmie ewolucji różnicowej najczęściej wykorzystywaną metodą odpowiedzialną za operacje krzyżowania jest krzyżowanie dwumianowe (ang. \textit{binomial}). Polega ono na przypisaniu do genu osobnika potomnego, wartości genu osobnika zmutowanego bądź też osobnika należącego do populacji rodzicielskiej. O wyborze z którego osobnika ma pochodzić gen wynikowy decyduje zależność wartości wylosowanej liczby zmiennoprzecinkowej z zakresu (0,1) i parametru krzyżowania $C_{r}$. Opisane wyżej zależności można przedstawić w formie zapisu.



$$
o_{i} = \left\{ \begin{array}{ll}
u_{i} & \textrm{,gdy $rand(0,1) \le C_{r}$}\\
x_{i} & \textrm{,gdy $rand(0,1) > C_{r}$}
\end{array} \right.
$$
gdzie $i = 1,...,n$
 
W celu wykorzystania metody krzyżowania w taki sposób by wektor wynikowy był permutacją danego zbioru, należy wprowadzić pewne modyfikacje w algorytmie działania tej metody. Modyfikacje te dotyczą sytuacji w której do osobnika wynikowego ma zostać wpisany gen, pochodzący od osobnika zmutowanego czy też od rodzica, który występuje już w osobniku wynikowym. Wówczas z pozostałych, nie wykorzystanych jeszcze, genów osobnika zmutowanego lub rodzica, zostaje losowany kolejny gen. Czynność ta jest powtarzana aż do momentu wylosowania genu, który nie zawiera się w osobniku wynikowym. Poniżej znajduje się implementacja metody krzyżowania dwumianowego wraz z modyfikacjami.

\begin{program}[h!]
\begin{lstlisting}[
 basicstyle=\scriptsize,]
	public List<int> BinomialCrossver(List<int> ParentIndividual, List<int> MutatedIndividual)
        {
            List<int> CrossedIndividual = new List<int>();
            Random random = new Random();
            double Cr = random.NextDouble();
            Random random2 = new Random();

            int size = ParentIndividual.Count;
            for (int i = 0; i < size; i++)
            {
                double Cr_tmp = random.NextDouble();

                if (Cr_tmp < Cr) // Mutated
                {
                    if (CrossedIndividual.Contains(MutatedIndividual[i]))
                    {
                        var ind = GiveRandomNumber(CrossedIndividual, MutatedIndividual.Count, random2);
                        CrossedIndividual.Add(ind);
                    }
                    else
                        CrossedIndividual.Add(MutatedIndividual[i]);
                }
                else //Parent
                {
                    if (CrossedIndividual.Contains(ParentIndividual[i]))
                    {
                        var ind = GiveRandomNumber(CrossedIndividual, ParentIndividual.Count, random2);
                        CrossedIndividual.Add(ind);
                    }
                    else
                        CrossedIndividual.Add(ParentIndividual[i]);
                }
            }
            return CrossedIndividual;
        }
\end{lstlisting}
\end{program}

%---------------------------------------------------------------------------

\section{Modyfikacje metod krzyżowania}\label{sec:strukturaDokumentu}

W literaturze \cite{crossovers} istnieją metody krzyżowania mające zastosowanie w przypadku osobników będących permutacjami pewnego zbioru. Poniżej zostały opisane zasady działania oraz implementacje poszczególnych metod krzyżowania.

%---------------------------------------------------------------------------

\subsection{Krzyżowanie OX}\label{sec:kompilacja}

Strategia OX ang.\textit{Order Crossover} zakłada utworzenie osobnika potomnego poprzez wybór podciągu w jednym z osobników będącym rodzicem \cite{cross}. Następnie podciąg ustawiany jest w potomku na miejscach o tych samych indeksach na których znajdował się on w osobniku będącym rodzicem. Pozostałe luki w osobniku potomnym wypełnianie są wartościami genów drugiego z rodziców, przy jednoczesnym sprawdzeniu czy osobnik potomny nie zawiera już danej wartości. Gen potomny jest dopełniany od lewej do prawej strony. Opisane zależności przedstawione zostały na poniższym schemacie.


\begin{figure}[h!]
\centering
		\includegraphics[scale=0.6]{../../../../Screeny/OXCross.png}
		\caption{Schemat działania operatora krzyżowania OX}
		\label{schematOX}			
\end{figure}

Długość podciągu oraz indeks jego początku również są losowane programowo. Implementacja metody krzyżowania OX została umieszczona poniżej.

\begin{program}[h!]
\begin{lstlisting}[
 basicstyle=\scriptsize,]
	public List<int> OXCrossver(List<int> ParentIndividual, List<int> MutatedIndividual)
        {
            List<int> CrossedIndividual = new List<int>();
            for (int i = 0; i < ParentIndividual.Count; i++)
            {
                CrossedIndividual.Add(0);
            }

            Random rnd = new Random();
            int offset = rnd.Next(0, ParentIndividual.Count);
            int length = rnd.Next(1, ParentIndividual.Count - offset);
            int iter = 0;
            while (iter != length)
            {
                CrossedIndividual[offset + iter] = MutatedIndividual[offset + iter];
                iter++;
            }

            for (int i = 0; i < ParentIndividual.Count; i++)
            {
                if (CrossedIndividual[i] == 0)
                {
                    var i_tmp = 0;
                    while(CrossedIndividual.Contains(ParentIndividual[i_tmp]))
                    {
                        i_tmp++;
                    }
                    CrossedIndividual[i] = ParentIndividual[i_tmp];
                }
            }
            return CrossedIndividual;
        }
\end{lstlisting}
\end{program}

%---------------------------------------------------------------------------

\subsection{Krzyżowanie CX}\label{sec:kompilacja}

Operacja krzyżowania CX  ang. \textit{Cycle Crossover} opiera się na utworzeniu domkniętego obiegu zawierającego w sobie elementy każdego z rodziców \cite{crossovers}. Obieg rozpoczyna się od pierwszego elementu osobnika zmutowanego, kolejny fragment stanowi zaś element znajdujący się na tej samej pozycji lecz w osobniku wywodzącym się z populacji rodzicielskiej. Następnie na podstawie wartości tego elementu odszukiwany jest odpowiadający mu gen w osobniku zmutowanym. Czynności te powtarzane są do chwili gdy kandydatem na dołączenie do obiegu jest gen odpowiadający wartości pierwszego elementu w obiegu. Sytuacja ta oznacza zakończenie pętli. \\
Geny osobnika zmutowanego, odznaczające się wartościami zawarytmi w obiegu, zostają wpisane na odpowiadających im pozycjach w genie wynikowym operacji. Dopełnienie luk zostaje realizowane poprzez inicjalizacje danej pozycji wartością pochodzącą od osobnika z populacji rodzicielskiej, w kolejności od lewej do prawej strony. Opisane wyżej zależności przedstawione zostały na ponizszym schemacie.

\begin{figure}[h!]
\centering
		\includegraphics[scale=0.6]{../../../../Screeny/crossCX.png}
		\caption{Schemat działania operatora krzyżowania CX}
		\label{schematCX}			
\end{figure}

Implementacja metody krzyżowania CX została umieszczona poniżej.

\begin{program}[h!]
\begin{lstlisting}[
 basicstyle=\scriptsize,]
        public List<int> CXCrossver(List<int> ParentIndividual, List<int> MutatedIndividual)
        {
            List<int> CrossedIndividual = new List<int>();
            for (int i = 0; i < ParentIndividual.Count; i++)
            {
                CrossedIndividual.Add(0);
            }

            CrossedIndividual[0] = MutatedIndividual[0];
            var index = 0;

            while (ParentIndividual[index] != MutatedIndividual[0])
            {
                index = MutatedIndividual.FindIndex(x => x == ParentIndividual[index]);
                CrossedIndividual[index] = MutatedIndividual[index];
            }

            for(int i = 0; i < ParentIndividual.Count; i++)
            {
                if (CrossedIndividual[i] == 0)
                {
                    var i_tmp = 0;
                    while (CrossedIndividual.Contains(ParentIndividual[i_tmp]))
                    {
                        i_tmp++;
                    }
                    CrossedIndividual[i] = ParentIndividual[i_tmp];
                }
            }
            return CrossedIndividual;
        }
\end{lstlisting}
\end{program}
%---------------------------------------------------------------------------

\subsection{Krzyżowanie PMX}\label{sec:kompilacja}

Metoda PMX ang. \textit{Partial-Mapped Crossover} jest jedną z bardziej skomplikowanych strategii krzyżowania. Jej działanie, podobnie jak uprzednio opisanych metod, jest zależne od osobników będących rodzicami. Spośród nich wybierany jest podciąg rozpoczynający się w miejscu o losowym indeksie i posiadający losową długość. Następnie dokonuje się wymiany podciągów pomiedzy dwoma rodzicami, w wyniku czego w osobnikach mogą wystąpić powtórzenia. Wówczas pomiędzy osobnikami tworzą się relacje mapowania, rysunek. Relacje te wykorzystywane są w celu usunięcia powtórzeń w osobnikach. Opisane zależności przedstawione są na poniższym schemacie.

\begin{figure}[h!]
\centering
		\includegraphics[scale=0.6]{../../../../Screeny/pmx_schemat.png}
		\caption{Schemat działania operatora krzyżowania PMX}
		\label{schematCX}			
\end{figure}

\begin{program}[h!]
\begin{lstlisting}[
 basicstyle=\scriptsize,]
        public List<int> PMXCrossver(List<int> ParentIndividual, List<int> MutatedIndividual)
        {
            List<int> Results = new List<int>();
            for (int i = 0; i < MutatedIndividual.Count; i++)
            {
                Results.Add(MutatedIndividual[i]);
            }

            List<int> Results2 = new List<int>();
            for (int i = 0; i < ParentIndividual.Count; i++)
            {
                Results2.Add(ParentIndividual[i]);
            }

            List<int> CrossedIndividual1 = new List<int>();
            List<int> CrossedIndividual2 = new List<int>();
            List<int> MutatedIndividualSubstring = new List<int>();
            List<int> ParentIndividualSubstring = new List<int>();
            Random rnd = new Random();
            int offset = rnd.Next(0, ParentIndividual.Count);
            int length = rnd.Next(1, ParentIndividual.Count - offset);
            int iter = 0;

            while (iter != length)
            {
                MutatedIndividualSubstring.Add(MutatedIndividual[offset + iter]);
                ParentIndividualSubstring.Add(ParentIndividual[offset + iter]);
                iter++;
            }

            for (int i = offset; i < offset + MutatedIndividualSubstring.Count; i++)
            {
                Results[i] = 0;
                Results2[i] = 0;
            }

            for (int i = 0; i < MutatedIndividualSubstring.Count; i++)
            {
                CrossedIndividual1.Add(MutatedIndividualSubstring[i]);
                CrossedIndividual2.Add(ParentIndividualSubstring[i]);
            }

            for (int i = 0; i < MutatedIndividualSubstring.Count; i++)
            {
                if (ParentIndividualSubstring.Contains(MutatedIndividualSubstring[i]))
                {
                    var index = ParentIndividualSubstring.FindIndex(x => x == MutatedIndividualSubstring[i]);
                    MutatedIndividualSubstring[i] = MutatedIndividualSubstring[index];
                    MutatedIndividualSubstring.RemoveAt(index);
                    ParentIndividualSubstring.RemoveAt(index);
                    i = -1;
                }
            }

            for (int i = 0; i < Results.Count; i++)
            {
                if (!Results.Contains(Results2[i]))
                {
                    int  index_2 = MutatedIndividualSubstring.FindIndex(x => x == Results2[i]);
                    var value = ParentIndividualSubstring[index_2];
                    var index = Results.FindIndex(x => x == value);
                    Results[index] = Results2[i];
                    Results2[i] = value;
                }
            }

            var i_tmp = 0;
            var i_tmp2 = 0;

            for (int i = 0; i < Results.Count; i++)
            {
                if (Results[i] == 0)
                {
                    Results[i] = CrossedIndividual2[i_tmp];
                    i_tmp ++;
                }
                if (Results2[i] == 0)
                {
                    Results2[i] = CrossedIndividual1[i_tmp2];
                    i_tmp2 ++;
                }
            }
            return Results;
        }
    }
\end{lstlisting}
\end{program}


























%---------------------------------------------------------------------------

\section{Dostrajanie parametrów krzyżowania}\label{dostrajaniecr}
